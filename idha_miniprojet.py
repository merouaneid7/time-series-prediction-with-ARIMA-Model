# -*- coding: utf-8 -*-
"""idha-miniprojet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oMP3lRs-CXRuIJBoZ44JlKSjNCrSJFga
"""

#Étape 1 : Chargement des données

"""**1.1-Importation des bibliothèques nécessaires**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""**1.2-Charger d'un fichier CSV :**"""

df=pd.read_csv("AirPassengers.csv", parse_dates = ['Month'], index_col = ['Month'])

"""**1.3-Afficher les 5 premiers lines du dataframe**"""

df.head(5)

#Étape 2 : Visualisation des données

"""**2.1-Convertir l'indice en format datetime et extrait uniquement la colonne #Passengers et la remplace comme série principale de df**"""

df.index=pd.to_datetime(df.index)
df=df["#Passengers"]

"""**2.1-Visualiser le serie**"""

plt.title("Evolution des Passagers Aériens")
plt.xlabel("Annee")
plt.ylabel("Nombre de passagers")
plt.plot(df)

#Etape 3 : Les opérations sur la série temporelle

"""**3.1-Rechantillonnage de la serie avec une frequence par année et calculer la moyenne pour chaque période. puis visualiser le serie**"""

resyear=df.resample('Y').mean()
plt.plot(resyear)

df.head()

"""**3.2-Deplacer la serie avec une periode de 5 mois en utilisant la methode shift qui prend comme parammetre le nombre de periodes**"""

df_shifted=df.shift(5)
plt.plot(df)
plt.plot(df_shifted)

"""**3.3-Calcule la somme des valeurs sur une fenêtre de taille 5 en utlisant la methode rolling qui sert a faire le windowing et le methode d'agrégation sum**"""

df.rolling(window=5).sum()

"""**3.4-Selectionner seulement les dates avec un nombre de passagers inférieur à 120.**"""

new_df=df[df<120]
new_df.index

new_df.head(10)

#Étape 4 : Vérification de la stationnarité de cette série temporelle

"""**4.1-Calculer a moyenne mobile avec sur une fenêtre de 12 periodes et en utlisant le methode d'agrégation mean**"""

mb=df.rolling(window=12).mean()

"""**4.2-Calculer la variance mobile avec sur une fenêtre de 12 periodes et en utlisant le methode d'agrégation var**"""

vm=df.rolling(window=12).var()

"""**4.2-Visulaiser la moyenne mobile et varicance mobile**"""

plt.figure(figsize=(12, 6))
plt.plot(df.index,df, color='blue')
plt.plot(mb.index,mb,color='orange')
plt.plot(vm.index,vm,color='green')

"""**On constate graphiquement qu'on a une tendance à la hausse et également une saisonnalité**

**4.3-D'où on va faire un test ADF pour être sûr**

**Importer la méthode adfuller d'après le package statsmodels**
"""

from statsmodels.tsa.stattools import adfuller

res=adfuller(df)

print("p-value = ",res[1])

"""**On constate que la p-value qui se situe dans la case 2 du résultat du test ADF est supérieure à 5 %, d'où la série n'est pas stationnaire**

**D'où il faut stationnariser la série, donc on va faire la première différenciation**
"""

#Étape 5 : Rendre le série temporelle

"""**5.1-Différenciation temporelle**"""

diff_df=np.diff(df)
plt.plot(diff_df)

"""**5.2-On va faire aussi la transformation logarithmique**"""

log_df=np.log(df)
plt.plot(log_df )

"""**On constate qu'il n'y a plus d'amplitude dans la série**

**5.3-On va maintenant faire la déscomposition saisonnière**
"""

from statsmodels.tsa.seasonal import seasonal_decompose

sesonal_res=seasonal_decompose(df,model='additive',period=12)
sesonal_res.plot()

sesonal_res=seasonal_decompose(df,model='multiplicative',period=12)
sesonal_res.plot()

"""**Après la décomposition, on constate que la série suit un modèle multiplicatif car le résidu est plus stable selon ce modèle**"""

#Étape 6 : Autocorrélation

"""**Maintenant on va calculer l'autocorrélation ACF et l'autocorrélation partielle PACF pour déterminer le modèle ARIMA approprié**"""

from statsmodels.tsa.stattools import acf,pacf

acf_values=acf(df,nlags=20)
acf_values

"""**On a calculé l'autocorrélation avec la méthode scf avec un nombre de décalage égal à 20, on distingue que**"""

pacf_values=pacf(df,nlags=20)
pacf_values

"""**On constate que les résultats montrent que les premiers lags (1 et 2) ont une forte corrélation, ce qui est important. Les lags plus éloignés ont des corrélations plus faibles ou négatives. Cela signifie que seuls les premiers lags (1 et 2) sont probablement utiles pour créer un modèle.**

**On va maintenant visualiser l'autocorrélation ACF et l'autocorrélation partielle PACF en utilisant les deux matrices plot_acf et plot_pacf**
"""

from statsmodels.graphics.tsaplots import plot_acf,plot_pacf

plot_acf(acf_values)

"""**On constate qu'après les trois premières valeurs, les autres valeurs dirigent vers 0**"""

plot_acf(pacf_values)

"""**On constate que après la première valeur, les autres valeurs dirigent vers 0**"""

#Étape 7 : Modélisation

"""**Maintenant on va passer au modèle ARIMA pour faire des prévisions**"""

from statsmodels.tsa.arima.model import ARIMA

"""**Pour l'ordre, on a 3 paramètres : p, d, q**

**p : on a choisi 2 car le résultat PACF indique qu'après une ou deux premières** **valeurs les autres commencent à diriger vers 0**

**d : on a choisi 1 car on a déjà fait une seule différentiation à notre modèle**

**q : on a choisi 2 car le résultat ACF indique que après 2 ou 3 premières valeurs les autres commencent à diriger vers 0**

"""

model=ARIMA(df,order=(2,1,2))

"""**On fait l'entraînement du modèle avec la méthode fit**"""

fit_model=model.fit()

print(fit_model.summary())

#Étape 8 : Prévisions

"""**Maintenant on va faire la prévision pour les prochains 12 mois**"""

forecast = fit_model.get_forecast(steps=12)
forecast_values = forecast.predicted_mean

plt.figure(figsize=(10, 6))
plt.plot(df)
plt.plot(forecast_values)

#Étape 9 : Interprétation des résultats

"""**9.1-On obtient un résultat logique, cela à cause du bon choix du modèle et également de l'ordre en se basant sur les résultats ACF et PACF**

**9.2/9.3- Les principaux facteurs influençant le nombre des passagers sont : une tendance à la hausse en fonction du temps (à cause du développement technologique dans le domaine) et une saisonnalité à chaque moitié d'année (période avec une grande demande)**
"""